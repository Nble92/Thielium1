import {
  AdapterBlueprint,
  W3mFrameProviderSingleton,
  WalletConnectConnector,
  WcHelpersUtil
} from "./chunk-ZKZMKY7P.js";
import "./chunk-FCW5CMGC.js";
import "./chunk-FF44UITQ.js";
import "./chunk-K6WP2HGY.js";
import "./chunk-ZVHMXIVC.js";
import {
  CaipNetworksUtil,
  ErrorUtil,
  PresetsUtil
} from "./chunk-DOD5XOL3.js";
import {
  AccountController,
  AlertController,
  ChainController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  NetworkUtil,
  OptionsController,
  StorageUtil,
  proxy,
  subscribeKey
} from "./chunk-S33C622M.js";
import "./chunk-HZ7WUKP6.js";
import "./chunk-SPJEADIR.js";
import "./chunk-A26QWC2D.js";
import "./chunk-KAPNL25W.js";
import "./chunk-OXZP3ONI.js";
import "./chunk-FUPOJN5U.js";
import {
  ChainNotConfiguredError,
  ProviderNotFoundError,
  connect,
  createConfig,
  createConnector,
  disconnect,
  estimateGas,
  getAccount,
  getBalance,
  getConnections,
  injected,
  prepareTransactionRequest,
  reconnect,
  sendTransaction,
  signMessage,
  switchChain,
  waitForTransactionReceipt,
  watchAccount,
  watchConnectors,
  watchPendingTransactions,
  writeContract
} from "./chunk-5AWO362F.js";
import "./chunk-YOLEXXBR.js";
import "./chunk-M6JLZ5G3.js";
import {
  parseUnits
} from "./chunk-HOY4MPC6.js";
import "./chunk-KHARAP2F.js";
import "./chunk-JCUDKKKT.js";
import "./chunk-3QJS76EB.js";
import "./chunk-XMWHA3GN.js";
import "./chunk-FXJNTRMK.js";
import "./chunk-7WBNIHIU.js";
import "./chunk-F6Q6LI7O.js";
import {
  SwitchChainError,
  UserRejectedRequestError,
  formatUnits,
  getAddress,
  numberToHex
} from "./chunk-4I4N3SLY.js";
import "./chunk-FJXQD5XT.js";
import "./chunk-BHYCPPRF.js";
import "./chunk-64NT3AJW.js";

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/AuthConnector.js
function authConnector(parameters) {
  let currentAccounts = [];
  let socialProvider = void 0;
  let connectSocialPromise = void 0;
  function parseChainId(chainId) {
    return NetworkUtil.parseEvmChainId(chainId) || 1;
  }
  function getProviderInstance() {
    if (!socialProvider) {
      socialProvider = W3mFrameProviderSingleton.getInstance({
        projectId: parameters.options.projectId,
        enableLogger: parameters.options.enableAuthLogger,
        onTimeout: (reason) => {
          if (reason === "iframe_load_failed") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
          } else if (reason === "iframe_request_timeout") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
          } else if (reason === "unverified_domain") {
            AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
          }
        },
        abortController: ErrorUtil.EmbeddedWalletAbortController
      });
    }
    return socialProvider;
  }
  async function connectSocial(options = {}) {
    var _a, _b;
    const provider = getProviderInstance();
    let chainId = options.chainId;
    if (options.isReconnecting) {
      const lastUsedChainId = NetworkUtil.parseEvmChainId(provider.getLastUsedChainId() || "");
      const defaultChainId = (_a = parameters.chains) == null ? void 0 : _a[0].id;
      chainId = lastUsedChainId || defaultChainId;
      if (!chainId) {
        throw new Error("ChainId not found in provider");
      }
    }
    const preferredAccountType = (_b = AccountController.state.preferredAccountTypes) == null ? void 0 : _b.eip155;
    const { address, chainId: frameChainId, accounts } = await provider.connect({
      chainId,
      preferredAccountType,
      socialUri: options.socialUri
    });
    currentAccounts = (accounts == null ? void 0 : accounts.map((a) => a.address)) || [address];
    const parsedChainId = parseChainId(frameChainId);
    return {
      accounts: currentAccounts,
      account: address,
      chainId: parsedChainId,
      chain: {
        id: parsedChainId,
        unsuported: false
      }
    };
  }
  return createConnector((config) => ({
    id: ConstantsUtil.CONNECTOR_ID.AUTH,
    name: ConstantsUtil.CONNECTOR_NAMES.AUTH,
    type: "AUTH",
    chain: ConstantsUtil.CHAIN.EVM,
    async connect(options = {}) {
      if (connectSocialPromise) {
        return connectSocialPromise;
      }
      if (!connectSocialPromise) {
        connectSocialPromise = new Promise((resolve) => {
          resolve(connectSocial(options));
        });
      }
      const result = await connectSocialPromise;
      connectSocialPromise = void 0;
      return result;
    },
    async disconnect() {
      const provider = await this.getProvider();
      await provider.disconnect();
    },
    getAccounts() {
      if (!(currentAccounts == null ? void 0 : currentAccounts.length)) {
        return Promise.resolve([]);
      }
      config.emitter.emit("change", { accounts: currentAccounts });
      return Promise.resolve(currentAccounts);
    },
    async getProvider() {
      if (!this.provider) {
        this.provider = W3mFrameProviderSingleton.getInstance({
          projectId: parameters.options.projectId,
          enableLogger: parameters.options.enableAuthLogger,
          abortController: ErrorUtil.EmbeddedWalletAbortController,
          onTimeout: (reason) => {
            if (reason === "iframe_load_failed") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_LOAD_FAILED, "error");
            } else if (reason === "iframe_request_timeout") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.IFRAME_REQUEST_TIMEOUT, "error");
            } else if (reason === "unverified_domain") {
              AlertController.open(ErrorUtil.ALERT_ERRORS.UNVERIFIED_DOMAIN, "error");
            }
          }
        });
      }
      return Promise.resolve(this.provider);
    },
    async getChainId() {
      const provider = await this.getProvider();
      const { chainId } = await provider.getChainId();
      return parseChainId(chainId);
    },
    async isAuthorized() {
      const provider = await this.getProvider();
      return Promise.resolve(provider.getLoginEmailUsed());
    },
    async switchChain({ chainId }) {
      var _a, _b;
      try {
        const chain = config.chains.find((c) => c.id === chainId);
        if (!chain) {
          throw new SwitchChainError(new Error("chain not found on connector."));
        }
        const provider = await this.getProvider();
        const preferredAccountType = (_a = AccountController.state.preferredAccountTypes) == null ? void 0 : _a.eip155;
        const response = await provider.connect({
          chainId,
          preferredAccountType
        });
        currentAccounts = ((_b = response == null ? void 0 : response.accounts) == null ? void 0 : _b.map((a) => a.address)) || [
          response.address
        ];
        config.emitter.emit("change", {
          chainId: Number(chainId),
          accounts: currentAccounts
        });
        return chain;
      } catch (error) {
        if (error instanceof Error) {
          throw new SwitchChainError(error);
        }
        throw error;
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", { accounts: accounts.map(getAddress) });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      const provider = await this.getProvider();
      await provider.disconnect();
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/connectors/UniversalConnector.js
walletConnect.type = "walletConnect";
function walletConnect(parameters, appKit) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let accountsChanged;
  let chainChanged;
  let connect2;
  let displayUri;
  let sessionDelete;
  let disconnect2;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider) {
        return;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ ...rest } = {}) {
      var _a, _b, _c;
      try {
        const caipNetworks = ChainController.getCaipNetworks();
        const provider = await this.getProvider();
        if (!provider) {
          throw new ProviderNotFoundError();
        }
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale) {
          await provider.disconnect();
        }
        const universalProviderConfigOverride = OptionsController.state.universalProviderConfigOverride;
        if (!provider.session || isChainsStale) {
          const namespaces = WcHelpersUtil.createNamespaces(caipNetworks, universalProviderConfigOverride);
          await provider.connect({
            optionalNamespaces: namespaces,
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(caipNetworks.map((x) => Number(x.id)));
        }
        const accounts = await this.getAccounts();
        const requestChainId = await this.getChainId();
        const chains = (_c = (_b = (_a = provider.session) == null ? void 0 : _a.namespaces) == null ? void 0 : _b["eip155"]) == null ? void 0 : _c.chains;
        const isRequestedChainSupported = chains == null ? void 0 : chains.some((chain) => Number(chain.split(":")[1]) === requestChainId);
        let currentChainId = 1;
        if (isRequestedChainSupported) {
          currentChainId = requestChainId;
        } else if (chains == null ? void 0 : chains[0]) {
          currentChainId = Number(chains[0].split(":")[1]);
        }
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect2) {
          provider.removeListener("connect", connect2);
          connect2 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect2) {
          disconnect2 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect2);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        const defaultChain = universalProviderConfigOverride == null ? void 0 : universalProviderConfigOverride.defaultChain;
        provider.setDefaultChain(defaultChain ?? `eip155:${currentChainId}`);
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await (provider == null ? void 0 : provider.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message)) {
          throw error;
        }
      } finally {
        if (chainChanged) {
          provider == null ? void 0 : provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect2) {
          provider == null ? void 0 : provider.removeListener("disconnect", disconnect2);
          disconnect2 = void 0;
        }
        if (!connect2) {
          connect2 = this.onConnect.bind(this);
          provider == null ? void 0 : provider.on("connect", connect2);
        }
        if (accountsChanged) {
          provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider == null ? void 0 : provider.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      var _a, _b, _c;
      const provider = await this.getProvider();
      if (!((_a = provider == null ? void 0 : provider.session) == null ? void 0 : _a.namespaces)) {
        return [];
      }
      const accountsList = (_c = (_b = provider == null ? void 0 : provider.session) == null ? void 0 : _b.namespaces[ConstantsUtil.CHAIN.EVM]) == null ? void 0 : _c.accounts;
      const accounts = (accountsList == null ? void 0 : accountsList.map((account) => account.split(":")[2])) ?? [];
      return accounts;
    },
    async getProvider({ chainId } = {}) {
      var _a, _b;
      if (!provider_) {
        provider_ = await appKit.getUniversalProvider();
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      const activeNamespace = StorageUtil.getActiveNamespace();
      const currentChainId = (_a = appKit.getCaipNetwork()) == null ? void 0 : _a.id;
      if (chainId && currentChainId !== chainId && activeNamespace) {
        const storedCaipNetworkId = StorageUtil.getStoredActiveCaipNetworkId();
        const appKitCaipNetworks = appKit.getCaipNetworks(activeNamespace);
        const storedCaipNetwork = appKitCaipNetworks == null ? void 0 : appKitCaipNetworks.find((n) => n.id === storedCaipNetworkId);
        if (storedCaipNetwork && storedCaipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM) {
          await ((_b = this.switchChain) == null ? void 0 : _b.call(this, { chainId: Number(storedCaipNetwork.id) }));
        }
      }
      return provider_;
    },
    async getChainId() {
      var _a, _b, _c, _d;
      const chainId = (_a = appKit.getCaipNetwork(ConstantsUtil.CHAIN.EVM)) == null ? void 0 : _a.id;
      if (chainId) {
        return chainId;
      }
      const provider = await this.getProvider();
      const chain = (_d = (_c = (_b = provider.session) == null ? void 0 : _b.namespaces[ConstantsUtil.CHAIN.EVM]) == null ? void 0 : _c.chains) == null ? void 0 : _d[0];
      const network = ChainController.getCaipNetworks().find((c) => c.id === chain);
      return network == null ? void 0 : network.id;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);
        if (!accounts.length) {
          return false;
        }
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a, _b, _c, _d;
      const provider = await this.getProvider();
      if (!provider) {
        throw new ProviderNotFoundError();
      }
      const chainToSwitch = ChainController.getCaipNetworks().find((x) => x.id === chainId);
      if (!chainToSwitch) {
        throw new SwitchChainError(new ChainNotConfiguredError());
      }
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        if (chainToSwitch == null ? void 0 : chainToSwitch.caipNetworkId) {
          provider.setDefaultChain(chainToSwitch == null ? void 0 : chainToSwitch.caipNetworkId);
        }
        config.emitter.emit("change", { chainId: Number(chainId) });
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return { ...chainToSwitch, id: chainToSwitch.id };
      } catch (err) {
        const error = err;
        if (/(?:user rejected)/iu.test(error.message)) {
          throw new UserRejectedRequestError(error);
        }
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls) {
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          } else {
            blockExplorerUrls = ((_a = chainToSwitch.blockExplorers) == null ? void 0 : _a.default.url) ? [(_b = chainToSwitch.blockExplorers) == null ? void 0 : _b.default.url] : [];
          }
          const rpcUrls = ((_d = (_c = chainToSwitch.rpcUrls) == null ? void 0 : _c["chainDefault"]) == null ? void 0 : _d.http) || [];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: chainToSwitch.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: chainToSwitch.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return { ...chainToSwitch, id: chainToSwitch.id };
        } catch (e) {
          throw new UserRejectedRequestError(e);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        this.onDisconnect();
      } else {
        config.emitter.emit("change", {
          accounts: accounts.map((x) => getAddress(x))
        });
      }
    },
    onChainChanged(chain) {
      const chainId = Number(chain);
      config.emitter.emit("change", { chainId });
    },
    onConnect(_connectInfo) {
      this.setRequestedChainsIds(ChainController.getCaipNetworks().map((x) => Number(x.id)));
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect2) {
        provider.removeListener("disconnect", disconnect2);
        disconnect2 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect2) {
        connect2 = this.onConnect.bind(this);
        provider.on("connect", connect2);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a, _b, _c;
      if (!((_a = provider_ == null ? void 0 : provider_.session) == null ? void 0 : _a.namespaces)) {
        return [];
      }
      const accounts = (_c = (_b = provider_ == null ? void 0 : provider_.session) == null ? void 0 : _b.namespaces[ConstantsUtil.CHAIN.EVM]) == null ? void 0 : _c.accounts;
      const chainIds = (accounts == null ? void 0 : accounts.map((account) => Number.parseInt(account.split(":")[1] ?? ""))) ?? [];
      return chainIds;
    },
    async getRequestedChainsIds() {
      var _a;
      const chainIds = await ((_a = config.storage) == null ? void 0 : _a.getItem(this.requestedChainsStorageKey)) ?? [];
      return [...new Set(chainIds)];
    },
    async isChainsStale() {
      if (!isNewChainsStale) {
        return false;
      }
      const connectorChains = config.chains.map((x) => x.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id) => connectorChains.includes(id))) {
        return false;
      }
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id) => requestedChains.includes(Number(id)));
    },
    async setRequestedChainsIds(chains) {
      var _a;
      await ((_a = config.storage) == null ? void 0 : _a.setItem(this.requestedChainsStorageKey, chains));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/LimitterUtil.js
var state = proxy({
  pendingTransactions: 0
});
var LimitterUtil = {
  state,
  subscribeKey(key, callback) {
    return subscribeKey(state, key, callback);
  },
  increase(value) {
    state[value] += 1;
  },
  decrease(value) {
    state[value] -= 1;
  },
  reset(value) {
    state[value] = 0;
  }
};

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/utils/helpers.js
function parseWalletCapabilities(str) {
  try {
    return JSON.parse(str);
  } catch (error) {
    throw new Error("Error parsing wallet capabilities");
  }
}

// node_modules/@reown/appkit-adapter-wagmi/dist/esm/src/client.js
var DEFAULT_PENDING_TRANSACTIONS_FILTER = {
  enable: false,
  pollingInterval: 3e4
};
var WagmiAdapter = class extends AdapterBlueprint {
  constructor(configParams) {
    const networks = CaipNetworksUtil.extendCaipNetworks(configParams.networks, {
      projectId: configParams.projectId,
      customNetworkImageUrls: {},
      customRpcUrls: configParams.customRpcUrls
    });
    super();
    this.balancePromises = {};
    this.namespace = ConstantsUtil.CHAIN.EVM;
    this.adapterType = ConstantsUtil.ADAPTER_TYPES.WAGMI;
    this.projectId = configParams.projectId;
    this.pendingTransactionsFilter = {
      ...DEFAULT_PENDING_TRANSACTIONS_FILTER,
      ...configParams.pendingTransactionsFilter ?? {}
    };
    this.createConfig({ ...configParams, networks });
  }
  construct(_options) {
    this.setupWatchers();
  }
  async getAccounts(params) {
    var _a;
    const connector = this.getWagmiConnector(params.id);
    if (!connector) {
      return { accounts: [] };
    }
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
      const provider = await connector.getProvider();
      if (!(provider == null ? void 0 : provider.user)) {
        return { accounts: [] };
      }
      const { address: address2, accounts } = provider.user;
      return Promise.resolve({
        accounts: (accounts || [{ address: address2, type: "eoa" }]).map((account) => CoreHelperUtil.createAccount("eip155", account.address, account.type))
      });
    }
    const { addresses, address } = getAccount(this.wagmiConfig);
    return Promise.resolve({
      accounts: (_a = addresses || [address]) == null ? void 0 : _a.map((val) => CoreHelperUtil.createAccount("eip155", val || "", "eoa"))
    });
  }
  getWagmiConnector(id) {
    return this.wagmiConfig.connectors.find((c) => c.id === id);
  }
  createConfig(configParams) {
    this.wagmiChains = configParams.networks.filter((caipNetwork) => caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM);
    const transports = {};
    const connectors = [...configParams.connectors ?? []];
    this.wagmiChains.forEach((element) => {
      var _a, _b;
      const fromTransportProp = (_a = configParams.transports) == null ? void 0 : _a[element.id];
      const caipNetworkId = CaipNetworksUtil.getCaipNetworkId(element);
      if (fromTransportProp) {
        transports[element.id] = CaipNetworksUtil.extendWagmiTransports(element, configParams.projectId, fromTransportProp);
      } else {
        transports[element.id] = CaipNetworksUtil.getViemTransport(element, configParams.projectId, (_b = configParams.customRpcUrls) == null ? void 0 : _b[caipNetworkId]);
      }
    });
    this.wagmiConfig = createConfig({
      ...configParams,
      chains: this.wagmiChains,
      connectors,
      transports
    });
  }
  setupWatchPendingTransactions() {
    if (!this.pendingTransactionsFilter.enable || this.unwatchPendingTransactions) {
      return;
    }
    this.unwatchPendingTransactions = watchPendingTransactions(this.wagmiConfig, {
      pollingInterval: this.pendingTransactionsFilter.pollingInterval,
      onError: () => {
      },
      onTransactions: () => {
        this.emit("pendingTransactions");
        LimitterUtil.increase("pendingTransactions");
      }
    });
    const unsubscribe = LimitterUtil.subscribeKey("pendingTransactions", (val) => {
      var _a;
      if (val >= ConstantsUtil.LIMITS.PENDING_TRANSACTIONS) {
        (_a = this.unwatchPendingTransactions) == null ? void 0 : _a.call(this);
        unsubscribe();
      }
    });
  }
  setupWatchers() {
    watchAccount(this.wagmiConfig, {
      onChange: (accountData, prevAccountData) => {
        if (accountData.status === "disconnected" && prevAccountData.address) {
          this.emit("disconnect");
        }
        if (accountData.status === "connected") {
          if (accountData.address !== (prevAccountData == null ? void 0 : prevAccountData.address) || prevAccountData.status !== "connected") {
            this.setupWatchPendingTransactions();
            this.emit("accountChanged", {
              address: accountData.address,
              chainId: accountData.chainId
            });
          }
          if (accountData.chainId !== (prevAccountData == null ? void 0 : prevAccountData.chainId)) {
            this.emit("switchNetwork", {
              address: accountData.address,
              chainId: accountData.chainId
            });
          }
        }
      }
    });
  }
  async addThirdPartyConnectors(options) {
    var _a, _b;
    const thirdPartyConnectors = [];
    if (options.enableCoinbase !== false) {
      try {
        const { coinbaseWallet } = await import("./exports-N3AGCQQQ.js");
        if (coinbaseWallet) {
          thirdPartyConnectors.push(coinbaseWallet({
            version: "4",
            appName: ((_a = options.metadata) == null ? void 0 : _a.name) ?? "Unknown",
            appLogoUrl: ((_b = options.metadata) == null ? void 0 : _b.icons[0]) ?? "Unknown",
            preference: options.coinbasePreference ?? "all"
          }));
        }
      } catch (error) {
        console.error("Failed to import Coinbase Wallet SDK:", error);
      }
    }
    thirdPartyConnectors.forEach((connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
    });
  }
  addWagmiConnectors(options, appKit) {
    var _a, _b, _c, _d, _e, _f;
    const customConnectors = [];
    if (options.enableWalletConnect !== false) {
      customConnectors.push(walletConnect(options, appKit));
    }
    if (options.enableInjected !== false) {
      customConnectors.push(injected({ shimDisconnect: true }));
    }
    const isEmailEnabled = ((_a = options.features) == null ? void 0 : _a.email) === void 0 ? ConstantsUtil2.DEFAULT_FEATURES.email : (_b = options.features) == null ? void 0 : _b.email;
    const socialsEnabled = ((_c = options.features) == null ? void 0 : _c.socials) ? ((_e = (_d = options.features) == null ? void 0 : _d.socials) == null ? void 0 : _e.length) > 0 : ((_f = options.features) == null ? void 0 : _f.socials) ?? ConstantsUtil2.DEFAULT_FEATURES.socials;
    if (isEmailEnabled || socialsEnabled) {
      customConnectors.push(authConnector({
        chains: this.wagmiChains,
        options: { projectId: options.projectId, enableAuthLogger: options.enableAuthLogger }
      }));
    }
    customConnectors.forEach((connector) => {
      const cnctr = this.wagmiConfig._internal.connectors.setup(connector);
      this.wagmiConfig._internal.connectors.setState((prev) => [...prev, cnctr]);
    });
  }
  async signMessage(params) {
    try {
      const signature = await signMessage(this.wagmiConfig, {
        message: params.message,
        account: params.address
      });
      return { signature };
    } catch (error) {
      throw new Error("WagmiAdapter:signMessage - Sign message failed");
    }
  }
  async sendTransaction(params) {
    const { chainId, address } = getAccount(this.wagmiConfig);
    const txParams = {
      account: address,
      to: params.to,
      value: Number.isNaN(Number(params.value)) ? BigInt(0) : BigInt(params.value),
      gas: params.gas ? BigInt(params.gas) : void 0,
      gasPrice: params.gasPrice ? BigInt(params.gasPrice) : void 0,
      data: params.data,
      chainId,
      type: "legacy",
      parameters: ["nonce"]
    };
    await prepareTransactionRequest(this.wagmiConfig, txParams);
    const tx = await sendTransaction(this.wagmiConfig, txParams);
    await waitForTransactionReceipt(this.wagmiConfig, { hash: tx, timeout: 25e3 });
    return { hash: tx };
  }
  async writeContract(params) {
    var _a;
    const { caipNetwork, ...data } = params;
    const chainId = Number(NetworkUtil.caipNetworkIdToNumber(caipNetwork.caipNetworkId));
    const tx = await writeContract(this.wagmiConfig, {
      chain: (_a = this.wagmiChains) == null ? void 0 : _a[chainId],
      chainId,
      address: data.tokenAddress,
      account: data.fromAddress,
      abi: data.abi,
      functionName: data.method,
      args: data.args,
      __mode: "prepared"
    });
    return { hash: tx };
  }
  async estimateGas(params) {
    try {
      const result = await estimateGas(this.wagmiConfig, {
        account: params.address,
        to: params.to,
        data: params.data,
        type: "legacy"
      });
      return { gas: result };
    } catch (error) {
      throw new Error("WagmiAdapter:estimateGas - error estimating gas");
    }
  }
  parseUnits(params) {
    return parseUnits(params.value, params.decimals);
  }
  formatUnits(params) {
    return formatUnits(params.value, params.decimals);
  }
  async addWagmiConnector(connector, options) {
    var _a;
    if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH || connector.id === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT) {
      return;
    }
    const provider = await connector.getProvider().catch(() => void 0);
    this.addConnector({
      id: connector.id,
      explorerId: PresetsUtil.ConnectorExplorerIds[connector.id],
      imageUrl: ((_a = options == null ? void 0 : options.connectorImages) == null ? void 0 : _a[connector.id]) ?? connector.icon,
      name: PresetsUtil.ConnectorNamesMap[connector.id] ?? connector.name,
      imageId: PresetsUtil.ConnectorImageIds[connector.id],
      type: PresetsUtil.ConnectorTypesMap[connector.type] ?? "EXTERNAL",
      info: connector.id === ConstantsUtil.CONNECTOR_ID.INJECTED ? void 0 : { rdns: connector.id },
      provider,
      chain: this.namespace,
      chains: []
    });
  }
  async syncConnectors(options, appKit) {
    watchConnectors(this.wagmiConfig, {
      onChange: (connectors) => connectors.forEach((connector) => this.addWagmiConnector(connector, options))
    });
    await Promise.all(this.wagmiConfig.connectors.map((connector) => this.addWagmiConnector(connector, options)));
    this.addWagmiConnectors(options, appKit);
    await this.addThirdPartyConnectors(options);
  }
  async syncConnection(params) {
    var _a;
    const { id } = params;
    const connections = getConnections(this.wagmiConfig);
    const connection = connections.find((c) => c.connector.id === id);
    const connector = this.getWagmiConnector(id);
    const provider = await (connector == null ? void 0 : connector.getProvider());
    return {
      chainId: Number(connection == null ? void 0 : connection.chainId),
      address: connection == null ? void 0 : connection.accounts[0],
      provider,
      type: (_a = connection == null ? void 0 : connection.connector.type) == null ? void 0 : _a.toUpperCase(),
      id: connection == null ? void 0 : connection.connector.id
    };
  }
  async connectWalletConnect(chainId) {
    const walletConnectConnector = this.getWalletConnectConnector();
    await walletConnectConnector.authenticate();
    const wagmiConnector = this.getWagmiConnector("walletConnect");
    if (!wagmiConnector) {
      throw new Error("UniversalAdapter:connectWalletConnect - connector not found");
    }
    const res = await connect(this.wagmiConfig, {
      connector: wagmiConnector,
      chainId: chainId ? Number(chainId) : void 0
    });
    if (res.chainId !== Number(chainId)) {
      await switchChain(this.wagmiConfig, { chainId: res.chainId });
    }
    return { clientId: await walletConnectConnector.provider.client.core.crypto.getClientId() };
  }
  async connect(params) {
    var _a, _b, _c, _d, _e;
    const { id, provider, type, info, chainId, socialUri } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    if (provider && info && connector.id === ConstantsUtil.CONNECTOR_ID.EIP6963) {
      (_a = connector.setEip6963Wallet) == null ? void 0 : _a.call(connector, { provider, info });
    }
    if (connector.uid === ((_c = (_b = this.wagmiConfig) == null ? void 0 : _b.state) == null ? void 0 : _c.current)) {
      const connection = (_e = (_d = this.wagmiConfig.state) == null ? void 0 : _d.connections) == null ? void 0 : _e.get(connector.uid);
      if (connection) {
        return {
          address: connection == null ? void 0 : connection.accounts[0],
          chainId: connection == null ? void 0 : connection.chainId,
          provider,
          type,
          id
        };
      }
    }
    const res = await connect(this.wagmiConfig, {
      connector,
      chainId: chainId ? Number(chainId) : void 0,
      socialUri
    });
    return {
      address: res.accounts[0],
      chainId: res.chainId,
      provider,
      type,
      id
    };
  }
  async reconnect(params) {
    const { id } = params;
    const connector = this.getWagmiConnector(id);
    if (!connector) {
      throw new Error("connectionControllerClient:connectExternal - connector is undefined");
    }
    await reconnect(this.wagmiConfig, {
      connectors: [connector]
    });
  }
  async getBalance(params) {
    const address = params.address;
    const caipNetwork = this.getCaipNetworks().find((network) => network.id === params.chainId);
    if (!address) {
      return Promise.resolve({ balance: "0.00", symbol: "ETH" });
    }
    if (caipNetwork && this.wagmiConfig) {
      const caipAddress = `${caipNetwork.caipNetworkId}:${params.address}`;
      const cachedPromise = this.balancePromises[caipAddress];
      if (cachedPromise) {
        return cachedPromise;
      }
      const cachedBalance = StorageUtil.getNativeBalanceCacheForCaipAddress(caipAddress);
      if (cachedBalance) {
        return { balance: cachedBalance.balance, symbol: cachedBalance.symbol };
      }
      this.balancePromises[caipAddress] = new Promise(async (resolve) => {
        var _a, _b;
        try {
          const chainId = Number(params.chainId);
          const balance = await getBalance(this.wagmiConfig, {
            address: params.address,
            chainId,
            token: (_b = (_a = params.tokens) == null ? void 0 : _a[caipNetwork.caipNetworkId]) == null ? void 0 : _b.address
          });
          StorageUtil.updateNativeBalanceCache({
            caipAddress,
            balance: balance.formatted,
            symbol: balance.symbol,
            timestamp: Date.now()
          });
          resolve({ balance: balance.formatted, symbol: balance.symbol });
        } catch (error) {
          console.warn("Appkit:WagmiAdapter:getBalance - Error getting balance", error);
          resolve({ balance: "0.00", symbol: "ETH" });
        }
      }).finally(() => {
        delete this.balancePromises[caipAddress];
      });
      return this.balancePromises[caipAddress] || { balance: "0.00", symbol: "ETH" };
    }
    return { balance: "", symbol: "" };
  }
  getWalletConnectProvider() {
    var _a;
    return (_a = this.getWagmiConnector("walletConnect")) == null ? void 0 : _a["provider"];
  }
  async disconnect() {
    const connections = getConnections(this.wagmiConfig);
    await Promise.all(connections.map(async (connection) => {
      const connector = this.getWagmiConnector(connection.connector.id);
      if (connector) {
        await disconnect(this.wagmiConfig, { connector });
      }
    }));
  }
  async switchNetwork(params) {
    await switchChain(this.wagmiConfig, { chainId: params.caipNetwork.id });
    await super.switchNetwork(params);
  }
  async getCapabilities(params) {
    var _a, _b;
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:getCapabilities - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:getCapabilities - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:getCapabilities - provider is undefined");
    }
    const walletCapabilitiesString = (_b = (_a = provider.session) == null ? void 0 : _a.sessionProperties) == null ? void 0 : _b["capabilities"];
    if (walletCapabilitiesString) {
      const walletCapabilities = parseWalletCapabilities(walletCapabilitiesString);
      const accountCapabilities = walletCapabilities[params];
      if (accountCapabilities) {
        return accountCapabilities;
      }
    }
    return await provider.request({ method: "wallet_getCapabilities", params: [params] });
  }
  async grantPermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:grantPermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:grantPermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:grantPermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_grantPermissions", params });
  }
  async revokePermissions(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:revokePermissions - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:revokePermissions - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:revokePermissions - provider is undefined");
    }
    return provider.request({ method: "wallet_revokePermissions", params });
  }
  async walletGetAssets(params) {
    if (!this.wagmiConfig) {
      throw new Error("connectionControllerClient:walletGetAssets - wagmiConfig is undefined");
    }
    const connections = getConnections(this.wagmiConfig);
    const connection = connections[0];
    const connector = connection ? this.getWagmiConnector(connection.connector.id) : null;
    if (!connector) {
      throw new Error("connectionControllerClient:walletGetAssets - connector is undefined");
    }
    const provider = await connector.getProvider();
    if (!provider) {
      throw new Error("connectionControllerClient:walletGetAssets - provider is undefined");
    }
    return provider.request({ method: "wallet_getAssets", params: [params] });
  }
  setUniversalProvider(universalProvider) {
    universalProvider.on("connect", () => {
      const connections = getConnections(this.wagmiConfig);
      const connector = this.getWagmiConnector("walletConnect");
      if (connector && !connections.find((c) => c.connector.id === connector.id)) {
        reconnect(this.wagmiConfig, {
          connectors: [connector]
        });
      }
    });
    this.addConnector(new WalletConnectConnector({
      provider: universalProvider,
      caipNetworks: this.getCaipNetworks(),
      namespace: "eip155"
    }));
  }
};
export {
  WagmiAdapter,
  authConnector
};
//# sourceMappingURL=@reown_appkit-adapter-wagmi.js.map
